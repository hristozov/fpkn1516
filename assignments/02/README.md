Този път домашното е съставено от две задачи. Тежестта им е еднаква.

Задача1
===============
Да се напише процедура `(zad1 start end f value)`, която намира сумата на всички числа `x` в целочисления интервал `[start;end]` за които `f(x) = value`.

За целта задължително трябва да използвате `(accumulate start next end term comb initial)` или `(accumulate-filter start next end term comb initial pred)`.

Примери
-------
`(zad1 1 10 (labda (x) (remainder x 2)) 0) -> 30 (= 2 + 4 + 6 + 8 + 10)`

`(zad1 1 10 (labda (x) (remainder x 2)) 1) -> 25 (= 1 + 3 + 5 + 7 + 9)`

Hint
----
Задачата може да се реши и с нормалния `accumulate`, и с `accumulate-filter`.

Задача 2
========
Да се напише процедура `(zad2 f g h)`, където `f`, `g` и `h` са процедури. Резултатът да е нова процедура `p(x)`, която има стойност:
- `f(x) * g(x)`, ако x се дели на 3
- `f(x) + g(x) + h(x)`, ако x се дели на 3 с остатък 1
- `f(x) - h(x)`, ако x се дели на 3 с остатък 2

Примери
-------
Нека имаме следните процедури:

`(define (plus-1 x) (+ x 1))`

`(define (2-times x) (* x 2))`

`(define (plus-3 x) (+ x 3))`

Тогава да вземем резултата от `zad2`:

`(define p (zad2 plus-1 2-times plus-3))`

Сега `p` трябва да връща следните стойности:

`(p 1) -> 8  [= (1 + 1) + (2 * 1) + (1 + 3)]`

`(p 2) -> -2 [= (2 + 1) - (2 + 3)]`

`(p 3) -> 24 [= (3 + 1) * (2 * 3)]`

Hint
----
Използването на `let` в решението ви ще ви улесни живота. :)
